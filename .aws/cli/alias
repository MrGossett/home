[toplevel]

config-keychain =
  !f() {
    ${1:?'Usage: aws config-keychain <profile>'}
    printf "AWS Access Key ID: "
    read access
    security add-generic-password -a "aws $1 access" -s "aws $1 access" -w "$access" -U login.keychain
    printf "AWS Secret Access Key: "
    read secret
    security add-generic-password -a "aws $1 secret" -s "aws $1 secret" -w "$secret" -U login.keychain
    printf "Default region name [$(aws configure get profile.$1.region || printf 'None')]: "
    read region
    aws configure set "profile.$1.region" $region
    aws configure set "profile.$1.credential_process" "aws keychain $1"
  }; f

keychain =
  !f() {
    ACCESS_KEY=$(security find-generic-password -s "aws $1 access" -w login.keychain)
    SECRET_KEY=$(security find-generic-password -s "aws $1 secret" -w login.keychain)
    echo \{\"AccessKeyId\":\""$ACCESS_KEY"\",\"SecretAccessKey\":\""$SECRET_KEY"\",\"Version\":1}
  }; f

whoami = sts get-caller-identity

list-sgs = ec2 describe-security-groups --query "SecurityGroups[].[GroupId, GroupName]" --output text

sg-rules = !f() { aws ec2 describe-security-groups \
    --query "SecurityGroups[].IpPermissions[].[FromPort,ToPort,IpProtocol,join(',',IpRanges[].CidrIp)]" \
    --group-id "$1" --output text; }; f

tostring =
  !f() {
    jp -f "${1}" 'to_string(@)'
  }; f

tostring-with-jq =
  !f() {
    cat "${1}" | jq 'tostring'
  }; f

authorize-my-ip =
  !f() {
    ip=$(aws myip)
    aws ec2 authorize-security-group-ingress --group-id ${1} --cidr $ip/32 --protocol tcp --port 22
  }; f

get-group-id =
  !f() {
    aws ec2 describe-security-groups --filters Name=group-name,Values=${1} --query SecurityGroups[0].GroupId --output text
  }; f

authorize-my-ip-by-name =
  !f() {
    group_id=$(aws get-group-id "${1}")
    aws authorize-my-ip "$group_id"
  }; f

# list all security group port ranges open to 0.0.0.0/0
public-ports = ec2 describe-security-groups \
  --filters Name=ip-permission.cidr,Values=0.0.0.0/0 \
  --query 'SecurityGroups[].{
    GroupName:GroupName,
    GroupId:GroupId,
    PortRanges:
      IpPermissions[?contains(IpRanges[].CidrIp, `0.0.0.0/0`)].[
        join(`:`, [IpProtocol, join(`-`, [to_string(FromPort), to_string(ToPort)])])
      ][]
  }'

# List or set your region
region = !f() { [[ $# -eq 1 ]] && aws configure set region "$1" || aws configure get region; }; f

find-access-key = !f() {
    clear_to_eol=$(tput el)
    for i in $(aws iam list-users --query "Users[].UserName" --output text); do
      printf "\r%sSearching...$i" "${clear_to_eol}"
      result=$(aws iam list-access-keys --output text --user-name "${i}" --query "AccessKeyMetadata[?AccessKeyId=='${1}'].UserName";)
      if [ -n "${result}" ]; then
         printf "\r%s%s is owned by %s.\n" "${lear_to_eol}" "$1" "${result}"
         break
      fi
    done
    if [ -z "${result}" ]; then
      printf "\r%sKey not found." "${clear_to_eol}"
    fi
  }; f

docker-ecr-login =
  !f() {
    region=$(aws configure get region)
    endpoint=$(aws ecr get-authorization-token --region $region --output text --query authorizationData[].proxyEndpoint)
    passwd=$(aws ecr get-authorization-token --region $region --output text --query authorizationData[].authorizationToken | base64 --decode | cut -d: -f2)
    docker login -u AWS -p $passwd $endpoint
  }; f

myip =
  !f() {
    dig +short myip.opendns.com @resolver1.opendns.com
  }; f

allow-my-ip =
  !f() {
    my_ip=$(aws myip)
    aws ec2 authorize-security-group-ingress --group-name ${1} --protocol ${2} --port ${3} --cidr $my_ip/32
  }; f

revoke-my-ip =
  !f() {
    my_ip=$(aws myip)
    aws ec2 revoke-security-group-ingress --group-name ${1} --protocol ${2} --port ${3} --cidr $my_ip/32
  }; f

allow-my-ip-all =
  !f() {
    aws allow-my-ip ${1} all all
  }; f

revoke-my-ip-all =
  !f() {
    aws revoke-my-ip ${1} all all
  }; f

config-orgs =
  !f() {
    id=$(aws organizations list-accounts --query "Accounts[?contains(Email, '$1')].Id" --output text --profile mlv)
    aws configure set "profile.$1.region" $(aws configure get profile.mlv.region)
    aws configure set "profile.$1.source_profile" mlv
    aws configure set "profile.$1.role_arn" "arn:aws:iam::$id:role/jit_admin"
  }; f

accounts =
  !f() {
    aws organizations list-accounts --profile mlv --query 'Accounts[*].[Id, Email, Name]' --output table
  }; f

profiles =
  !f() {
    cat ~/.aws/config | grep '\[' | tr -d '[]' | cut -f 2 -d ' '
  }; f

find-account =
  !f() {
      aws organizations list-accounts --query "Accounts[?contains(Email, '$1')]" --profile mlv
  }; f

straight-jacket =
  !f() {
    policy='{"Version":"2012-10-17","Statement":[{"Effect":"Deny","Action":["iam:ChangePassword"],"Resource":["arn:aws:iam::*:user/${aws:username}"]},{"Effect":"Deny","Action":["iam:CreateUser","iam:*Policy"],"Resource":"*"}]}'
    aws iam create-policy --policy-name straight-jacket --policy-document "$policy"
    account="$(aws sts get-caller-identity --query 'Account' --output text)"
    arn="arn:aws:iam::$account:policy/straight-jacket"
    aws iam attach-user-policy --user-name "$1" --policy-arn "$arn"
  }; f

# $1: target profile
# $2: role name
trust-me =
  !f() {
    arn=$(aws whoami --query 'Arn' --output text)
    assume=$(aws iam get-role --role-name "$2" --profile "$1" --query 'Role.AssumeRolePolicyDocument')
    updated=$(jq --arg ARN "$arn" '.Statement += [(.Statement[0] as $stmt | $stmt + { Sid: "trustme"} | .Principal.AWS = "\($ARN)")]' <<<"$assume")
    aws iam update-assume-role-policy --role-name "$2" --policy-document "$updated" --profile "$1"
  }; f
